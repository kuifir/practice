一个适当的equals()方法必须满足以下五个条件：
- 1. 自反性：对于任意的x,调用x.equals(x)时应该返回true。
- 2. 对称性：对于任意的x和y,当且仅当y.equals(x)返回true时，x.equals(y)返回true。
- 3. 传递性：对于任意的x、y和z,如果x.equals(y)和y.equals(z)都返回true,那么x.equals(z)也应该返回true。
- 4. 一致性：对于任意的x和y,如果对象中用于相等性比较的信息没有被修改过，那么多次调用x.equals(y)应该始终返回true或false。
- 5. 对于任意非空的x,调用x.equals(null)应该返回false。

下面是满足这些条件的一系列测试，它可以确定自身与所比较的对象（在这里称为rval）是否相等。
- 1.如果rval为null,则两个对象不相等。
- 2.如果rval为this对象（即自己和自己比较），则两个对象相等。
- 3.如果rval不是this对象所属的类或子类，则两个对象不相等。
- 4.如果以上测试都通过，接下来就需要确定rval中哪些字段是重要的（并且是一致的），然后对它们进行比较。
Java7中引入了Objects类来帮助完成上述流程，它可以帮助我们编写出更好的equals()方法。

理解hashCode()

- 首先，考虑一下使用哈希背后的动机：用一个对象去查找另一个对象。但你也可以适合用TreeMap来完成此操作，甚至可以实现一个自己的Map。
- 一个生成比较好的hashCode()的基本准则：
    1.把一个非零常数，比如17，保存在一个叫result的变量中。
    2.对于对象中的每个重要字段f(即equals()方法会考虑的每个字段)，计算出该字段的int类型的哈希码c。
    3.组合上面计算出来的哈希码：result = 37 *　result +c。
    4.发布会result值。
    5.观察得到的hashCode()，确保相等的实例具有相同的哈希码。