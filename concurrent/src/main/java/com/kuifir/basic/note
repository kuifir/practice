    Java并发的核心机制是Thread类。在这门语言最初的版本中,Thread本来是打算让程序员直接创建和管理的。
随着语言的演进，人们发现了更好的方法，中间机制——特别时Executor——被加入进来，以消除自行管理多线程的
精神负担（和出现的错误）。最后甚至发展出了更优于Executor的机制，如parallel Stream 和CompletableFuture。
    Thread是一种将任务和处理器关联起来的软件结构。虽然Thread的创建和使用看起来和任何其他类没什么不同，
但是，它们的内在区别其实很大。在你创建Thread时，JVM会在一块专为Thread保留的内存区域中分配一大块空间，
从而为任务的运行提供所需的一切。
    - 一个程序计数器，指示要执行的下一条JVM字节码指令。
    - 一个支持Java代码执行的栈，包含该线程到达当前执行节点前所调用过的方法的相关信息。它同时还包含正在
执行的方法的所有本地变量（包括基本类型和堆上对象的引用）。在 ` 每个线程` 中，该栈的大小通常在64kB和1M
之间。（在某些平台上，尤其是Windows,可能非常难以找出栈空间的默认值。可以通过 -Xss标志调整栈空间的大小）。
    - 一个用于本地代码的栈
    - 本地线程变量(thread-local variable)存储
    - 用于控制线程的状态维护变量。

    包括main()在内的所有代码都运行在某个线程之内。只要有方法被调用，当前的程序计数器便会跳向该线程的栈，
然后栈指针会向下移动足够的距离，创建出一个栈帧(stack frame),其中包含该方法的所有本地变量、参数以及返回值
的存储。所有的本地基本类型会直接放在该栈上。方法所创建的对象的引用全部保存在该栈帧内，而对象本身则放到堆上。
堆只有一个，被程序中所以的线程所共享。
    除此之外，Thread必须由操作系统(OS)进行注册，这样它才可以在某个时机被真正关联到处理器上。这会作为Thread
构造过程的一部分来管理。Java通过底层操作系统的这种机制来管理多线程的执行。